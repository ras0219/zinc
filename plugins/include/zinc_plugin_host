#ifndef _ZINC_PLUGIN_HOST_HPP_
#define _ZINC_PLUGIN_HOST_HPP_

#include <string>
#include <map>
#include <vector>
#include <cassert>
#include <zinc_plugin>
#include <zinc_dlfcn>

namespace zinc {
  struct LibraryManager {
    typedef std::map<std::string, LibraryHandle*> libraries_t;
    typedef libraries_t::iterator iterator;

    ~LibraryManager() {
      auto it = libraries.begin();
      while (it != libraries.end())
        unload_library_file(it++);
    }

    LibraryHandle* load_library_file(const std::string& filename);

    // Cannot unload libraries at the moment
    inline void unload_library_file(const std::string& filename) { }
    inline void unload_library_file(LibraryHandle* lib) { }
    inline void unload_library_file(iterator it) { }

    Plugin* locate_plugin(const std::string& filename, const std::string& pluginname);

  private:
    libraries_t libraries;
  };

  struct InterfaceUnifier {
    std::vector<Interface*> available;

    // returns nullptr upon failure
    Interface*
    unify_request(const InterfaceRequest& req);

    // returns size 0 vector upon failure
    std::vector<Interface*>
    unify_request(std::size_t num_reqs, const InterfaceRequest* reqs);

    // returns size 0 vector upon failure
    inline std::vector<Interface*>
    unify_request(const Plugin* plug)
      { return unify_request(plug->num_reqs, plug->reqs); }
  };
}

#endif

// Local Variables:
// mode: c++
// End:
